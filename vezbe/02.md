# Vežbe | 2. termin

## _Operator overloading_

Operatori su funkcije koje imaju drugačiju sintaksu poziva od klasičnih funkcija.

Sintaksa poziva funkcije `Saberi`:
```cs
int s = Saberi(x, y);
```

Sintaksa poziva operatora `+`:
```cs
int s = x + y;
```

Po broju operanada operatori u C# mogu biti: **unarni** (`-x`, `x++`), **binarni** (`x + y`, `x < y`) i **ternarni** (`z ? x : y`).

U klasama koje kreiramo možemo definisati ponašanje operatora koji se poziva nad objektom te klase.

### Definisanje operatora

Operatore definišemo po sledećoj sintaksi:

```cs
public static TypeToReturn operator +(OperandTypeA a, OperandTypeA b) {
    // povratna vrednost mora biti tipa TypeToReturn
}
```

Ovde je prikazan binarni operator `+`. Za unarne operatore sintaksa je ista, razlikuju se jedino po broju parametara, unarni bi imao samo jedan parametar.

Primer za unarni operator negacije (`-`):

```cs
public static TypeToReturn operator -(OperandType a) {
    // povratna vrednost mora biti tipa TypeToReturn
}
```

Ovde moramo ispoštovati par pravila:
- Tip bar jednog operanda **mora** biti tip klase u kojoj definišemo ponašanje ovog operatora
- Drugi operand može biti istog ili nekog drugog tipa
- Povratni tip može biti bilo kog tipa

### Primer

Imamo klasu koja predstavlja tačku 2D prostoru:

```cs
public class Point2D
{
    public double x;
    public double y;

    public Point2D(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
}
```

Prvo, devinisaćemo **operator sabiranja** koji će sabirati dve tačke:

```cs
public static Point2D operator +(Point2D a, Point2D b)
{
    double x = a.x + b.x;
    double y = a.y + b.y;
    
    return new Point2D(x, y);
}
```

Kao povratnu vrednost dobijamo referencu na novokreirani Point2D objekat čiji su atributi `x` i `y` dobijeni sabiranjem vrednosti atributa druge dve tačke.

Isti želimo da uradimo i za _operator oduzimanja_. Mogli bismo da samo kopiramo prethodni kod i kod sabiranja vrednosti atrivuta zamenimo `+` za `-`. Ali, imamo i drugi način.

Možemo definisati unarni _operator negacije_, i iskoristi njega i prethodno definisani _operator sabiranja_, i preko njih definišemo _operator oduzimanja_.

Unarni **operator negacije**:

```cs
public static Point2D operator -(Point2D a)
{
    a.x = -a.x;
    a.y = -a.y;
    return a;
}
```

Povratna vrednost operatora će biti referenca na isti `Point2D` objekat koji je i učestvovao u operaciji (nije se kreirao novi objekat).

Sada, **operator oduzimanja** možemo definisati vrlo jednostavno na sledeći način:

```cs
public static Point2D operator -(Point2D a, Point2D b)
{
    return a + (-b);
}
```

U `Main` metodi možemo istestirati ove operatore:

```cs
Point2D a = new Point2D(1, 2);
Point2D b = new Point2D(10, 20);
Point2D c = new Point2D(17, 17);

var p = c - (b + a); // p je Point2D

Console.WriteLine("Tačka p: " + p.x + ", " + p.y);
```

Dobijamo ispis:

```
Tacka p: 6, -5
```


## Konverzija tipova - _Cast_

Operacija konverzije tipa (_cast_) je _unarni operator_. 

Za tipove koje kreiramo (klase) možemo definisati ponašanje operatora konverzije. Pri definisanju navodimo da li se to odnosi na **implicitnu** ili **eksplicitnu** konverziju.

_Implicitna konverzija_ se dešava automatski, u slučajevima kada konverija neće dovesti do gubljenja podataka, kao na primer konverzija `int` u `float`. Skup vrednosti koje `int` može uzeti je manji od onog kod `float`-a, pa je moguća implicitna konverzija, koja se dešava u ovakvim situacijama: `float x = 123;`

_Eksplicitna konverzija_ se dešava na zahtev, kada eksplicitno navedemo da želimo da se konverzija dogodi. Ona je neophodna u slučajevima kada bi zbog konverzije došlo do nekakvog gubitka podataka, kao u slučaju konverzije `float` u `int`. Primer: `int x = (int)123.45f`

Ponašanje operatora konverzije definišemo na sledeći način:

- Konverzija nekog drugog tipa u tip naše klase:
    ```cs
    public static explicit operator MyClass(OtherType x) {
        // Povratna vrednost mora biti MyClass
    }
    ```

- Konverzija tipa naše klaseu neki drugi tip:
    ```cs
    public static explicit operator OtherType(MyClass x) {
        // Povratna vrednost mora biti OtherType
    }
    ```

Ako je reč o konverziji koja bi trebalo da se desi implicitno, umesto ključne reči `explicit` pišemo `implicit`.

Operator konverzije koji definišemo u nekoj klasi mora vršiti konverziju ili iz tipa te klase, ili u tip te klase.


### Primer

U sledećem primeru definisaćemo _cast_ operator za knverziju iz `Point2D` u `double` niz, i obratno.

Prvo, kako bi smo sebi olakšali posao, kreiraćemo konstruktor koji prima `bouble` niz, i ukoliko postoje prva 2 elementa, njih uzima za vrednosti `x` i `y` atributa, redom, a ukoliko ne postoje ovi atributi će ostati `0`.

```cs
public class Point2D
{
    public double x = 0;
    public double y = 0;

    public Point2D(double[] arr)
    {
        if (arr.Length > 0)
            x = arr[0];

        if (arr.Length > 1)
            y = arr[1];
    }
}
```

U istoj klasi (`Point2D`) definisaćemo 2 operatora konverzije:
- _implicitnu_, iz `Point2D` u `double[]`
- _eksplicitnu_, iz `double[]` u `Point2D`

```cs
public static implicit operator double[](Point2D p)
{ 
    // Konstrukcija novog double niza sa potsavljenim članovima
    return new double[] { p.x, p.y }; 
}

public static explicit operator Point2D(double[] arr)
{
    // Konstruktor prima niz i već poseduje logiku za konverziju u Point2D
    return new Point2D(arr);
}
```

U `Main` metodi možemo isprobati ove konverzije:

```cs
Point2D p1 = new Point2D(1.0, 2.0);
double[] arr = point;       // <- Implicitna konverzija
Point2D p2 = (Point2D)arr;  // <- Eksplicitna konverzija
```

TODO: Objasniti kako se var uklapa u ovu priču.

## Indekseri (TODO)

## Podrška za foreach petlju (TODO)
