# Vežbe | 2. termin

## _Operator overloading_

Operatori su funkcije koje imaju drugačiju sintaksu poziva od klasičnih funkcija.

Sintaksa poziva funkcije `Saberi`:
```cs
int s = Saberi(x, y);
```

Sintaksa poziva operatora `+`:
```cs
int s = x + y;
```

Po broju operanada operatori u C# mogu biti: **unarni** (`-x`, `x++`), **binarni** (`x + y`, `x < y`) i **ternarni** (`z ? x : y`).

U klasama koje kreiramo možemo definisati ponašanje operatora koji se poziva nad objektom te klase.

### Definisanje operatora

Operatore definišemo po sledećoj sintaksi:

```cs
public static TypeToReturn operator +(OperandTypeA a, OperandTypeA b) {
    // povratna vrednost mora biti tipa TypeToReturn
}
```

Ovde je prikazan binarni operator `+`. Za unarne operatore sintaksa je ista, razlikuju se jedino po broju parametara, unarni bi imao samo jedan parametar.

Primer za unarni operator negacije (`-`):

```cs
public static TypeToReturn operator -(OperandType a) {
    // povratna vrednost mora biti tipa TypeToReturn
}
```

Ovde moramo ispoštovati par pravila:
- Tip bar jednog operanda **mora** biti tip klase u kojoj definišemo ponašanje ovog operatora
- Drugi operand može biti istog ili nekog drugog tipa
- Povratni tip može biti bilo kog tipa

### Primer

Imamo klasu koja predstavlja tačku 2D prostoru:

```cs
public class Point2D
{
    public double x;
    public double y;

    public Point2D(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
}
```

Prvo, devinisaćemo **operator sabiranja** koji će sabirati dve tačke:

```cs
public static Point2D operator +(Point2D a, Point2D b)
{
    double x = a.x + b.x;
    double y = a.y + b.y;
    
    return new Point2D(x, y);
}
```

Kao povratnu vrednost dobijamo referencu na novokreirani Point2D objekat čiji su atributi `x` i `y` dobijeni sabiranjem vrednosti atributa druge dve tačke.

Isti želimo da uradimo i za _operator oduzimanja_. Mogli bismo da samo kopiramo prethodni kod i kod sabiranja vrednosti atrivuta zamenimo `+` za `-`. Ali, imamo i drugi način.

Možemo definisati unarni _operator negacije_, i iskoristi njega i prethodno definisani _operator sabiranja_, i preko njih definišemo _operator oduzimanja_.

Unarni **operator negacije**:

```cs
public static Point2D operator -(Point2D a)
{
    a.x = -a.x;
    a.y = -a.y;
    return a;
}
```

Povratna vrednost operatora će biti referenca na isti `Point2D` objekat koji je i učestvovao u operaciji (nije se kreirao novi objekat).

Sada, **operator oduzimanja** možemo definisati vrlo jednostavno na sledeći način:

```cs
public static Point2D operator -(Point2D a, Point2D b)
{
    return a + (-b);
}
```

U `Main` metodi možemo istestirati ove operatore:

```cs
Point2D a = new Point2D(1, 2);
Point2D b = new Point2D(10, 20);
Point2D c = new Point2D(17, 17);

var p = c - (b + a); // p je Point2D

Console.WriteLine("Tačka p: " + p.x + ", " + p.y);
```

Dobijamo ispis:

```
Tacka p: 6, -5
```


## Konverzija tipova - _Cast_

Operacija konverzije tipa (_cast_) je _unarni operator_. 

Za tipove koje kreiramo (klase) možemo definisati ponašanje operatora konverzije. Pri definisanju navodimo da li se to odnosi na **implicitnu** ili **eksplicitnu** konverziju.

_Implicitna konverzija_ se dešava automatski, u slučajevima kada konverija neće dovesti do gubljenja podataka, kao na primer konverzija `int` u `float`. Skup vrednosti koje `int` može uzeti je manji od onog kod `float`-a, pa je moguća implicitna konverzija, koja se dešava u ovakvim situacijama: `float x = 123;`

_Eksplicitna konverzija_ se dešava na zahtev, kada eksplicitno navedemo da želimo da se konverzija dogodi. Ona je neophodna u slučajevima kada bi zbog konverzije došlo do nekakvog gubitka podataka, kao u slučaju konverzije `float` u `int`. Primer: `int x = (int)123.45f`

Ponašanje operatora konverzije definišemo na sledeći način:

- Konverzija nekog drugog tipa u tip naše klase:
    ```cs
    public static explicit operator MyClass(OtherType x) {
        // Povratna vrednost mora biti MyClass
    }
    ```

- Konverzija tipa naše klaseu neki drugi tip:
    ```cs
    public static explicit operator OtherType(MyClass x) {
        // Povratna vrednost mora biti OtherType
    }
    ```

Ako je reč o konverziji koja bi trebalo da se desi implicitno, umesto ključne reči `explicit` pišemo `implicit`.

Tip klase u kojoj definišemo _cast_ mora biti ili onaj tip koji konvertujemo ili u koga konvertujemo (TODO: Preformulisati)

TODO: Primer (može za Point2D), korišćenje u Main, objašnjenje za implicit i eksplicit. Eventualno ubaciti i var u priču sa ovim.

## Indekseri

- TODO

## Podrška za foreach petlju

- TODO