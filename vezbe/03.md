# Vežbe | 3. termin

## Sadržaj

- [Pojmovi](#pojmovi)
- [Delegati](#delegati)
- [Anonimne funkcije](#anonimne-funkcije)
    - [Delegat sintaksa](#delegat-sintaksa)
    - [Lambda izraz](#lambda-izrazi)
    - [Korišćenje](#korišćenje)
- [Događaji](#korišćenje)


## Pojmovi

|Pojam|Značenje|
|-|-|
|_Delegat_|Tip koji opisuje potpis funkcije|
|_Anonimna funkcija_|Funkcija koja nema ime|
|_Lambda izraz_|Izraz kojim se kreira _anonimna funkcija_|
|_Predikat_|Funkcija koja prima jedan parametar i vraća `bool` (TODO: Izbaciti ukoliko se prebacuje u naredni termin)|
|_Događaj_|TODO|

## Delegati

Delegat je tip koji opisuje potpis funkcije.

## Anonimne funkcije

Anonimna funkcija nema ime, kreira se samo navođenjem potpisa i tela sa implementacijom.

Naravno, da bi se takva funkcija koristila, moramo sačuvati referencu na nju, i pozivati je preko te reference.

Anonimna funkcija se može kreirati na više načina. U nastavku ćemo proći kroz dva: _Delegat sintaksa_ i _Lambda izraz_.

### Delegat sintaksa

```
delegate (parametri) { naredbe }
```
Parametri **moraju** imati naveden tip.

#### Primer

Delegat (tip funkcije) `BinaryOp` je definisan kao:
```cs
delegate int BinaryOp(int a, int b);
```

Anonimnu funkciju ćemo kreirati na sledeći način:
```cs
BinaryOp add = delegate (int x, int y) {
    return x + y;
};
```

### Lambda izrazi

Izraz koji kreira novu anonimnu funkciju i vraća referencu na nju.

```
(parametri) => izraz
(parametri) => { naredbe }
```
Parametri **ne** moraju imati naveden tip.

#### Primer

Koristićemo delegat `BinaryOp` iz primera _delegat sintakse_.

Anonimnu funkciju ćemo kreirati na sledeći način
```cs
BinaryOp add = (x, y) => x + y;
```

Umesto izraza možemo napisati blok sa naredbama:
```cs
BinaryOp add = (x, y) => {
    return x + y;
};
```

### Korišćenje

U prethodnim primerima smo kreirali anonimnu funkciju koja sabira dva broja. Referencu na tu funkciju smo čuvali u promenljivoj `add`. 

Sada, funkciju možemo pozivati preko te promenljive:
```cs
int result = add(17, 33);
```

## Događaji

```cs
public delegate void TempChangeHandler(double temp);
```

```cs
class Termometer
{
    double current = 20;

    public event TempChangeHandler TempChange;

    public void Start()
    {
        Random rnd = new Random();

        while (true)
        {
            Thread.Sleep(1000);               // Čekanje, 1000 milisekundi
            int change = rnd.Next(3) - 1;     // Moguće vrednosti: -1, 0, 1
            current += change;                // Temperatura će se smanjiti, povećati ili ostati ista

            if (change != 0)
                TempChange?.Invoke(current);  // Poziv svih prijavljenih metoda, ukoliko je došlo do promene
        }
    }
}
```

Kada nema prijavljenih metoda event `TempChange` će biti `null`. Ukoliko tada aktiviramo event dobićemo grešku `NullReferenceException`. Zato moramo proveriti da li je event `null`, i aktivirati ga samo ukoliko nije. Možemo koristiti `?.` operator, koji evaluira ceo poziv u `null` ukoliko je `TempChange` `null` i tada ne radi poziv metode `Invoke`, a u suprotnom regularno poziva `Invoke`. Drugi način za ovu proveru bi bio:

```cs
if (change != 0 && TempChange != null)
    TempChange(current); // ili TempChange.Invoke(current)
```

Takođe, kreiraćemo klasu sa metodom koja ispisuje temperaturu:

```cs
class TempLogger
{
    public void Log(double temp)
    {
        Console.WriteLine("[Logger] " + temp);
    }
}
```

Sada ćemo prijaviti više različitih tipova metoda/funkcija na event `TempChange`:

```cs
static class Program
{
    static void LogTemp(double temp)
    {
        Console.WriteLine("[Static] " + temp);
    }

    public static void Main(string[] args)
    {
        var sensor = new Termometer();
        var logger = new TempLogger();

        sensor.TempChange += LogTemp;                                  // Statička metoda (nema "this")
        sensor.TempChange += logger.Log;                               // Metoda uvezana sa objektom (ima "this")
        sensor.TempChange += t => Console.WriteLine("[Anonim] " + t);  // Anonimna funkcija

        sensor.Start();
    }
}
```

Svaki put kada se temperatura promeni u konzoli se ispisuje:

```
[Static] broj
[Logger] broj
[Anonim] broj
```